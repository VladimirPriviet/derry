import pygame
import sys
import math
import random
import os # Importante para manipular arquivos de áudio temporários

# ===== CORREÇÃO DA IMPORTAÇÃO MOVIEPY =====
# Tenta importar de forma compatível com versão antiga e nova (2.0)
try:
    from moviepy import VideoFileClip
except ImportError:
    try:
        from moviepy.editor import VideoFileClip
    except ImportError:
        VideoFileClip = None
        print("AVISO: MoviePy não instalado. O vídeo de introdução não será exibido.")

# ===== 1. CONFIGURAÇÕES =====
class Settings:
    # Começa com um tamanho padrão, mas vai mudar se você redimensionar a janela
    SCREEN_WIDTH = 800
    SCREEN_HEIGHT = 600
    FPS = 60
    
    # ZOOM ALTO (Tensão)
    TILE_SIZE = 120  

    # Cores do Esgoto
    COLOR_BG = (10, 10, 10)          
    COLOR_WALL = (80, 80, 80)     
    COLOR_WALL_3 = (130, 40, 40)     
    COLOR_FLOOR = (25, 30, 35)       

    # Cores do Poço (Mais escuro)
    COLOR_WELL_BG = (0, 0, 0)            
    COLOR_WELL_WALL = (25, 25, 25)       
    COLOR_WELL_FLOOR = (15, 10, 10)      
    COLOR_WELL_CRACKED = (20, 15, 15)    

# ===== 2. DEFINIÇÃO DOS MAPAS =====

# --- MAPA 1: O ESGOTO PRINCIPAL (60x60) ---
MAPA_ESGOTO = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,1,2,2,2,2,2,1,1,1,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1],
    [1,0,0,1,2,1,1,1,2,1,1,2,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,2,2,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1],
    [1,0,0,2,2,1,1,1,2,2,2,2,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1],
    [1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,0,0,0,1,1,1,2,2,2,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1],
    [1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,0,0,0,0,0,1,2,2,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,2,2,1,1,2,1,1,1,1,1,1,1],
    [1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,1,0,0,1,0,0,1,2,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,2,1,1,2,2,2,2,2,2,2,1],
    [1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1],
    [1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,1],
    [1,1,2,1,1,1,1,2,2,2,2,2,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,1,1,1,1,1,2,1,1,2,1],
    [1,1,2,1,1,1,2,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,3,3,3,2,2,3,3,3,1,1,2,1,1,2,1],
    [1,1,2,1,1,2,2,1,1,1,1,2,2,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,3,3,2,2,2,2,2,2,3,3,1,2,1,1,2,1],
    [1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,3,3,2,2,3,3,3,3,2,2,3,3,1,2,1,1,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,2,2,3,1,1,1,1,3,2,2,3,1,2,2,2,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,2,2,3,1,1,1,1,1,1,3,2,2,3,1,1,1,1,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,3,3,2,2,3,1,1,1,1,1,1,1,1,3,2,3,3,1,1,1,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,3,3,2,2,3,3,1,1,1,2,2,2,1,1,3,2,2,3,1,1,1,1],
    [1,2,1,1,1,1,2,2,2,2,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,3,2,2,3,1,1,1,2,2,1,2,2,1,1,3,2,3,1,1,1,1],
    [1,2,1,1,1,2,2,1,1,1,2,2,1,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,1,1,1,1,3,2,2,3,1,1,2,2,1,1,1,2,2,1,3,2,3,1,1,1,1],
    [1,2,1,1,2,2,1,1,1,1,1,2,2,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,3,3,2,3,1,1,2,1,1,1,1,1,2,1,3,2,3,1,1,1,1],
    [1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,3,2,3,1,2,2,1,1,1,1,1,2,1,3,2,3,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,2,2,2,2,2,2,2,2,1,1,1,3,2,3,1,2,1,1,1,1,1,1,2,1,3,2,3,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,3,2,3,1,2,1,1,1,1,1,1,2,1,3,2,3,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,2,1,1,3,3,2,3,3,2,1,1,1,1,1,1,2,1,3,2,3,1,1,1,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,3,2,2,2,3,2,2,2,2,2,2,2,2,1,3,2,3,1,1,1,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,3,2,2,2,3,3,3,3,3,3,3,3,3,1,3,2,3,1,1,1,1],
    [1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,2,1,2,1,1,3,3,2,2,2,2,2,2,2,2,2,2,3,3,3,2,3,1,1,1,1],
    [1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,1,1,2,2,2,1,1,1,3,3,3,3,3,3,3,3,3,3,2,3,2,2,2,3,1,1,1,1],
    [1,2,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,1],
    [1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,1],
    [1,1,1,2,1,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,1],
    [1,1,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,3,2,3,2,1,1,1,1,1,1,1],
    [1,1,1,2,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,2,2,2,2,3,2,3,2,3,3,3,3,3,3,1],
    [1,1,1,2,2,2,1,1,2,2,2,2,2,2,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,3,2,3,2,3,2,2,2,2,3,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,3,2,3,3,3,2,3,3,2,3,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,3,2,2,2,2,2,3,3,2,3,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,2,2,2,2,2,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,3,3,3,3,3,2,3,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,2,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,1],
    [1,2,2,2,2,2,2,1,1,2,2,2,2,1,2,1,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,1],
    [1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1,1,2,2,2,2,1,1,2,2,2,2,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,1],
    [1,0,0,0,0,1,2,1,1,2,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,2,2,2,2,2,1,2,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,1,2,2,2,2,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,2,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,2,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,3,3,3,3,3,3,3,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,2,1,2,1,1,1,1,1,1,1,3,2,2,2,2,2,3,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,2,1,2,2,2,2,2,2,2,2,3,2,3,3,3,2,3,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,3,2,3,1,3,2,3,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,1,1,1,1,1,1,1,3,2,3,1,3,2,3,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,3,3,1,3,3,3,1],
]

CENTER_Y_MAIN, CENTER_X_MAIN = len(MAPA_ESGOTO) // 2, len(MAPA_ESGOTO[0]) // 2
RADIUS_FLOOR_MAIN = 2.5 
RADIUS_WALL_MAIN = 3.5   

for y in range(len(MAPA_ESGOTO)):
    for x in range(len(MAPA_ESGOTO[0])):
        dist_sq = (x - CENTER_X_MAIN)**2 + (y - CENTER_Y_MAIN)**2
        if dist_sq <= RADIUS_FLOOR_MAIN**2:
            MAPA_ESGOTO[y][x] = 2 
        elif dist_sq <= RADIUS_WALL_MAIN**2:
            if MAPA_ESGOTO[y][x] != 2: 
                MAPA_ESGOTO[y][x] = 3

# --- MAPA 2: CORREDOR SUBINDO ---
def gerar_mapa_corredor_subida():
    width = 20
    height = 40
    mapa = [[9 for _ in range(width)] for _ in range(height)]
    center_x = width // 2
    start_y = 36
    room_center_y = 6

    # Corredor
    for y in range(start_y, room_center_y + 2, -1):
        mapa[y][center_x] = 7 
        mapa[y][center_x-1] = 8 
        mapa[y][center_x+1] = 8 

    # Sala Final 3x3
    room_radius = 3.0 
    wall_radius = 4.0
    
    for y in range(height):
        for x in range(width):
            dist = math.hypot(x - center_x, y - room_center_y)
            if dist <= room_radius:
                mapa[y][x] = 6 
            elif dist <= wall_radius:
                if mapa[y][x] != 7 and y <= room_center_y + 3:
                    mapa[y][x] = 8 
    
    mapa[start_y+1][center_x] = 8
    return mapa, center_x, start_y, room_center_y

MAPA_POCO, START_X_POCO, START_Y_POCO, IT_Y_POCO = gerar_mapa_corredor_subida()

# ===== 3. CLASSE CÂMERA =====
class Camera:
    def __init__(self, width, height):
        self.camera = pygame.Rect(0, 0, width, height)
        self.width = width
        self.height = height

    def apply(self, entity_rect):
        return entity_rect.move(self.camera.topleft)

    def update(self, target):
        x = -target.rect.centerx + int(Settings.SCREEN_WIDTH / 2)
        y = -target.rect.centery + int(Settings.SCREEN_HEIGHT / 2)
        x = min(0, max(-(self.width - Settings.SCREEN_WIDTH), x))
        y = min(0, max(-(self.height - Settings.SCREEN_HEIGHT), y))
        self.camera = pygame.Rect(x, y, self.width, self.height)

# ===== 4. CLASSE PENNYWISE (IT) =====
class Pennywise(pygame.sprite.Sprite):
    def __init__(self, x, y, image_path):
        super().__init__()
        try:
            img = pygame.image.load(image_path).convert_alpha()
        except pygame.error as e:
            print(f"Erro ao carregar IT: {e}")
            sys.exit()

        p_width = int(Settings.TILE_SIZE * 2.0)
        p_height = int(Settings.TILE_SIZE * 2.5)
        self.image = pygame.transform.scale(img, (p_width, p_height))
        self.rect = self.image.get_rect()
        
        self.rect.center = (x * Settings.TILE_SIZE + Settings.TILE_SIZE // 2, 
                            y * Settings.TILE_SIZE + Settings.TILE_SIZE // 2)

# ===== 5. GERENCIADOR DE OBJETOS =====
class ObjectHandler2D:
    def __init__(self, game):
        self.game = game 
        self.objects = []
        self.tex_stone = self.generate_stone_tex()
        self.tex_eyes = self.generate_eyes_tex()
        self.tex_well = self.generate_well_tex()

    def generate_stone_tex(self):
        s = pygame.Surface((Settings.TILE_SIZE, Settings.TILE_SIZE), pygame.SRCALPHA)
        radius = int(Settings.TILE_SIZE * 0.2)
        center = (Settings.TILE_SIZE // 2, Settings.TILE_SIZE // 2)
        pygame.draw.circle(s, (150, 150, 150), center, radius) 
        pygame.draw.circle(s, (50, 50, 50), center, radius, 2)
        return s

    def generate_eyes_tex(self):
        s = pygame.Surface((Settings.TILE_SIZE, Settings.TILE_SIZE), pygame.SRCALPHA)
        eye_offset = int(Settings.TILE_SIZE * 0.15)
        eye_radius = int(Settings.TILE_SIZE * 0.08)
        center = (Settings.TILE_SIZE // 2, Settings.TILE_SIZE // 2)
        pygame.draw.circle(s, (255, 255, 0), (center[0]-eye_offset, center[1]), eye_radius)
        pygame.draw.circle(s, (255, 255, 0), (center[0]+eye_offset, center[1]), eye_radius)
        return s

    def generate_well_tex(self):
        s = pygame.Surface((Settings.TILE_SIZE, Settings.TILE_SIZE), pygame.SRCALPHA)
        center = (Settings.TILE_SIZE // 2, Settings.TILE_SIZE // 2)
        pygame.draw.circle(s, (100, 100, 100), center, int(Settings.TILE_SIZE * 0.4))
        pygame.draw.circle(s, (0, 0, 0), center, int(Settings.TILE_SIZE * 0.3))
        return s

    def populate(self, mapa_atual):
        self.objects = [] 
        rows = len(mapa_atual)
        cols = len(mapa_atual[0])
        
        if self.game.mapa_atual_id == 0:
            well_rect = pygame.Rect(CENTER_X_MAIN * Settings.TILE_SIZE, CENTER_Y_MAIN * Settings.TILE_SIZE, Settings.TILE_SIZE, Settings.TILE_SIZE)
            self.objects.append({'type': 'well', 'rect': well_rect, 'visible': True})

            for y in range(1, rows - 1):
                for x in range(1, cols - 1):
                    try:
                        if mapa_atual[y][x] in (0, 2):
                            walls = 0
                            colors_wall = (1, 3)
                            if mapa_atual[y-1][x] in colors_wall: walls += 1
                            if mapa_atual[y+1][x] in colors_wall: walls += 1
                            if mapa_atual[y][x-1] in colors_wall: walls += 1
                            if mapa_atual[y][x+1] in colors_wall: walls += 1
                            
                            if walls >= 3:
                                if x < 10 and y < 10: continue
                                dist_to_center = math.hypot(x - CENTER_X_MAIN, y - CENTER_Y_MAIN)
                                if dist_to_center < 1.5: continue 

                                rect = pygame.Rect(x * Settings.TILE_SIZE, y * Settings.TILE_SIZE, Settings.TILE_SIZE, Settings.TILE_SIZE)
                                self.objects.append({'type': 'stone', 'rect': rect, 'visible': True})
                                self.objects.append({'type': 'eyes', 'rect': rect, 'visible': False})
                    except IndexError:
                        continue

    def update(self, player_rect):
        keys = pygame.key.get_pressed()
        if keys[pygame.K_e]:
            for obj in self.objects:
                if obj['visible']:
                    if player_rect.colliderect(obj['rect'].inflate(10, 10)):
                        if obj['type'] == 'stone':
                            obj['visible'] = False
                            for eye in self.objects:
                                if eye['type'] == 'eyes' and eye['rect'] == obj['rect']:
                                    eye['visible'] = True
                            print("PEDRA PEGA!")
                        elif obj['type'] == 'well':
                            print("SUBINDO O CORREDOR...")
                            self.game.enter_well()

    def draw(self, screen, camera):
        for obj in self.objects:
            if obj['visible']:
                rect_on_screen = camera.apply(obj['rect'])
                if -Settings.TILE_SIZE < rect_on_screen.x < Settings.SCREEN_WIDTH and -Settings.TILE_SIZE < rect_on_screen.y < Settings.SCREEN_HEIGHT:
                    if obj['type'] == 'stone':
                        screen.blit(self.tex_stone, rect_on_screen)
                    elif obj['type'] == 'eyes':
                        screen.blit(self.tex_eyes, rect_on_screen)
                    elif obj['type'] == 'well':
                        screen.blit(self.tex_well, rect_on_screen)

# ===== 6. CLASSE JOGADOR =====
class AnimatedPlayer(pygame.sprite.Sprite):
    def __init__(self, x, y, image_path):
        super().__init__()
        try:
            original_image = pygame.image.load(image_path).convert_alpha()
            colorkey = original_image.get_at((0, 0))
            original_image.set_colorkey(colorkey)
        except pygame.error as e:
            print(f"Erro: {e}")
            sys.exit()

        p_width = int(Settings.TILE_SIZE * 0.6) 
        p_height = int(Settings.TILE_SIZE * 0.9)
        self.base_image = pygame.transform.scale(original_image, (p_width, p_height))
        self.images = {
            'down': self.base_image,
            'up': self.base_image,
            'left': pygame.transform.flip(self.base_image, True, False),
            'right': self.base_image
        }
        self.image = self.images['down']
        self.rect = self.image.get_rect()
        self.speed = 9 
        self.vel_x = 0
        self.vel_y = 0
        self.direction = 'down'
        self.animation_timer = 0
        self.animation_speed = 150 
        self.walking_frame = 0
        self.is_walking = False
        self.set_pos(x, y)

    def set_pos(self, x, y):
        self.rect.topleft = (x * Settings.TILE_SIZE + (Settings.TILE_SIZE - self.rect.width) // 2, 
                             y * Settings.TILE_SIZE + (Settings.TILE_SIZE - self.rect.height) // 2)

    def update(self, walls_rects, dt, pennywise_sprite=None):
        self.vel_x = 0
        self.vel_y = 0
        keys = pygame.key.get_pressed()
        
        if keys[pygame.K_k]:
             if len(walls_rects) > 0:
                 max_x = max([w.right for w in walls_rects])
                 max_y = max([w.bottom for w in walls_rects])
                 self.rect.center = (max_x // 2, max_y // 2)

        self.is_walking = False
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.vel_x = -self.speed
            self.direction = 'left'
            self.is_walking = True
        elif keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.vel_x = self.speed
            self.direction = 'right'
            self.is_walking = True
        elif keys[pygame.K_UP] or keys[pygame.K_w]:
            self.vel_y = -self.speed
            self.direction = 'up'
            self.is_walking = True
        elif keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.vel_y = self.speed
            self.direction = 'down'
            self.is_walking = True

        self.image = self.images[self.direction]
        if self.is_walking:
            self.animation_timer += dt
            if self.animation_timer >= self.animation_speed:
                self.animation_timer = 0
                self.walking_frame = (self.walking_frame + 1) % 2
            if self.walking_frame == 1:
                 offset = 6 
                 self.image = pygame.Surface(self.rect.size, pygame.SRCALPHA)
                 self.image.blit(self.images[self.direction], (0, -offset))
        else:
            self.walking_frame = 0
            self.animation_timer = 0

        # COLISÃO
        collidables = list(walls_rects)
        if pennywise_sprite:
            collidables.append(pennywise_sprite.rect)

        self.rect.x += self.vel_x
        for obstacle in collidables:
            if self.rect.colliderect(obstacle):
                if self.vel_x > 0: self.rect.right = obstacle.left
                if self.vel_x < 0: self.rect.left = obstacle.right

        self.rect.y += self.vel_y
        for obstacle in collidables:
            if self.rect.colliderect(obstacle):
                if self.vel_y > 0: self.rect.bottom = obstacle.top
                if self.vel_y < 0: self.rect.top = obstacle.bottom

# ===== 7. JOGO PRINCIPAL =====
class Game:
    def __init__(self):
        pygame.init()
        # IMPORTANTE: Inicializa o mixer para o áudio do vídeo
        pygame.mixer.init()
        
        # FULLSCREEN/RESIZABLE
        self.screen = pygame.display.set_mode((Settings.SCREEN_WIDTH, Settings.SCREEN_HEIGHT), pygame.RESIZABLE)
        
        pygame.display.set_caption("Derry Sewers 2D - FINAL")
        self.clock = pygame.time.Clock()
        
        self.player = AnimatedPlayer(4, 2, "image_9.png")
        self.obj_handler = ObjectHandler2D(self)
        self.pennywise = None 
        
        self.mapa_atual_id = 0 
        self.load_map(MAPA_ESGOTO)

    def play_intro(self):
        """ Toca a intro frame a frame (Sem usar preview) """
        if not VideoFileClip: return 
        if not os.path.exists("intro.mp4"): 
            print("Vídeo 'intro.mp4' não encontrado.")
            return

        try:
            clip = VideoFileClip("intro.mp4")
            
            # Extrai e toca áudio
            if clip.audio:
                audio_path = "temp_intro_audio.mp3"
                clip.audio.write_audiofile(audio_path, logger=None)
                pygame.mixer.music.load(audio_path)
                pygame.mixer.music.play()

            running = True
            
            # Loop de frames
            for frame in clip.iter_frames(fps=Settings.FPS, dtype="uint8"):
                if not running: break
                
                # Eventos (Pular com espaço ou esc)
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit(); sys.exit()
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_SPACE or event.key == pygame.K_ESCAPE:
                            running = False
                            pygame.mixer.music.stop()

                # Redimensiona e desenha
                # O MoviePy entrega (Altura, Largura, Cor), Pygame precisa trocar eixos
                frame_surf = pygame.surfarray.make_surface(frame.swapaxes(0, 1))
                # Redimensiona para o tamanho atual da janela
                frame_surf = pygame.transform.scale(frame_surf, self.screen.get_size())
                
                self.screen.blit(frame_surf, (0, 0))
                pygame.display.flip()
                self.clock.tick(Settings.FPS)

            # Limpeza
            if clip.audio:
                pygame.mixer.music.stop()
                try: 
                    clip.close()
                    os.remove(audio_path)
                except: pass
                
        except Exception as e:
            print(f"Erro ao tocar vídeo: {e}")
        
        # Limpa tela ao sair
        self.screen.fill((0,0,0))
        pygame.display.flip()

    def load_map(self, mapa_data):
        self.walls = []
        self.floor_tiles = []
        self.pennywise = None 
        
        rows = len(mapa_data)
        cols = len(mapa_data[0])
        map_pixel_width = cols * Settings.TILE_SIZE
        map_pixel_height = rows * Settings.TILE_SIZE
        
        for row, tiles in enumerate(mapa_data):
            for col, tile in enumerate(tiles):
                rect = pygame.Rect(col * Settings.TILE_SIZE, row * Settings.TILE_SIZE, Settings.TILE_SIZE, Settings.TILE_SIZE)
                
                if tile == 1: self.walls.append({'rect': rect, 'color': Settings.COLOR_WALL})
                elif tile == 3: self.walls.append({'rect': rect, 'color': Settings.COLOR_WALL_3})
                elif tile == 2: self.floor_tiles.append({'rect': rect, 'color': Settings.COLOR_FLOOR})
                elif tile == 0: self.floor_tiles.append({'rect': rect, 'color': (35, 35, 35)})
                elif tile == 8: self.walls.append({'rect': rect, 'color': Settings.COLOR_WELL_WALL})
                elif tile == 7: self.floor_tiles.append({'rect': rect, 'color': Settings.COLOR_WELL_FLOOR})
                elif tile == 6: self.floor_tiles.append({'rect': rect, 'color': Settings.COLOR_WELL_CRACKED})
        
        self.camera = Camera(map_pixel_width, map_pixel_height)
        self.obj_handler.populate(mapa_data)

    def enter_well(self):
        self.mapa_atual_id = 1
        pygame.display.set_caption("Derry Sewers 2D - THE ASCENSION")
        self.load_map(MAPA_POCO)
        
        self.player.set_pos(START_X_POCO, START_Y_POCO) 
        self.pennywise = Pennywise(START_X_POCO, IT_Y_POCO, "image_17.png")

    def show_start_screen(self):
        # Carrega a imagem de fundo e dimensiona para a tela
        try:
            bg_image = pygame.image.load("image_16.png").convert()
        except pygame.error:
            print("Erro ao carregar image_16.png para a tela inicial.")
            # Cria um fundo preto caso a imagem falhe
            bg_image = pygame.Surface((Settings.SCREEN_WIDTH, Settings.SCREEN_HEIGHT))
            bg_image.fill((0, 0, 0))

        # Cria o botão
        font = pygame.font.SysFont(None, 50)
        text = font.render("Iniciar Jogo", True, (255, 255, 255))
        button_rect = pygame.Rect(0, 0, 250, 60)
        button_rect.center = (Settings.SCREEN_WIDTH // 2, Settings.SCREEN_HEIGHT - 100)

        waiting_for_start = True
        while waiting_for_start:
            # Eventos
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    # Verifica se clicou no botão com o botão esquerdo
                    if event.button == 1 and button_rect.collidepoint(event.pos):
                        waiting_for_start = False
                if event.type == pygame.VIDEORESIZE:
                    # Atualiza o tamanho da tela e recalcula a posição do botão
                    Settings.SCREEN_WIDTH = event.w
                    Settings.SCREEN_HEIGHT = event.h
                    self.screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)
                    button_rect.center = (Settings.SCREEN_WIDTH // 2, Settings.SCREEN_HEIGHT - 100)

            # Desenho
            # Redimensiona a imagem de fundo para o tamanho atual da janela
            scaled_bg = pygame.transform.scale(bg_image, (Settings.SCREEN_WIDTH, Settings.SCREEN_HEIGHT))
            self.screen.blit(scaled_bg, (0, 0))
            
            # Desenha o botão
            pygame.draw.rect(self.screen, (200, 50, 50), button_rect) # Cor vermelha
            pygame.draw.rect(self.screen, (255, 255, 255), button_rect, 2) # Borda branca
            
            # Centraliza o texto no botão
            text_rect = text.get_rect(center=button_rect.center)
            self.screen.blit(text, text_rect)
            
            pygame.display.flip()
            self.clock.tick(Settings.FPS)

    def run(self):
        # 1. Toca o vídeo primeiro
        self.play_intro()
        
        # 2. Mostra a tela de menu (que você já tinha)
        self.show_start_screen() 
        
        # 3. Começa o jogo
        while True:
            dt = self.clock.tick(Settings.FPS)
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        pygame.quit()
                        sys.exit()
                
                # Resizable Window Handler
                if event.type == pygame.VIDEORESIZE:
                    Settings.SCREEN_WIDTH = event.w
                    Settings.SCREEN_HEIGHT = event.h
                    self.screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)

            wall_rects = [w['rect'] for w in self.walls]
            
            current_pennywise = self.pennywise if self.mapa_atual_id == 1 else None
            self.player.update(wall_rects, dt, current_pennywise)
            self.obj_handler.update(self.player.rect)
            self.camera.update(self.player)

            bg_color = Settings.COLOR_BG if self.mapa_atual_id == 0 else Settings.COLOR_WELL_BG
            self.screen.fill(bg_color)

            for tile in self.floor_tiles:
                rect_on_screen = self.camera.apply(pygame.Rect(tile['rect']))
                if -Settings.TILE_SIZE < rect_on_screen.x < Settings.SCREEN_WIDTH and -Settings.TILE_SIZE < rect_on_screen.y < Settings.SCREEN_HEIGHT:
                    pygame.draw.rect(self.screen, tile['color'], rect_on_screen)

            self.obj_handler.draw(self.screen, self.camera)

            for wall in self.walls:
                rect_on_screen = self.camera.apply(pygame.Rect(wall['rect']))
                if -Settings.TILE_SIZE < rect_on_screen.x < Settings.SCREEN_WIDTH and -Settings.TILE_SIZE < rect_on_screen.y < Settings.SCREEN_HEIGHT:
                    pygame.draw.rect(self.screen, wall['color'], rect_on_screen)

            if self.pennywise:
                 self.screen.blit(self.pennywise.image, self.camera.apply(self.pennywise.rect))

            self.screen.blit(self.player.image, self.camera.apply(self.player.rect))

            pygame.display.flip()

if __name__ == "__main__":
    game = Game()
    game.run()
